#Instantaneous interface
# nrego sept 2015

from __future__ import division; __metaclass__ = type
import sys
import numpy as np
from math import sqrt
import argparse
from argparse import ArgumentTypeError
import logging

import cPickle as pickle


import MDAnalysis
from MDAnalysis import SelectionError
#from MDAnalysis.coordinates.xdrfile.libxdrfile2 import read_xtc_natoms, xdrfile_open

from scipy.spatial import cKDTree
import itertools
#from skimage import measure
import mdtraj

from rhoutils import rho, cartesian
from mdtools import ParallelTool, Subcommand

from constants import SEL_SPEC_HEAVIES, SEL_SPEC_HEAVIES_NOWALL

from fieldwriter import RhoField

log = logging.getLogger('mdtools.temporal_interface')


## Try to avoid round-off errors as much as we can...
rho_dtype = np.float32


def _calc_rho(frame_idx, water_ow, n_pts_included, gridpt_mask, gridpt_mask_assign, x_bounds, y_bounds, z_bounds):

    rho_slice = np.zeros(n_pts_included, dtype=rho_dtype)
    
    x_assign = np.digitize(water_ow[:,0], x_bounds) - 1
    y_assign = np.digitize(water_ow[:,1], y_bounds) - 1
    z_assign = np.digitize(water_ow[:,2], z_bounds) - 1

    y_len = y_bounds.size
    z_len = z_bounds.size

    ## assignment of each water (indices in n_pts_total)
    assign_all = z_assign + (y_assign*z_len) + (x_assign*y_len*z_len)
    # assignments of only waters within included voxels (indices in n_pts_total)
    assign_included = assign_all[gridpt_mask[assign_all]]
    # assignments of only waters within included voxels (indices in n_pts_included)
    assign_included_indices = gridpt_mask_assign[assign_included]

    rho_slice[assign_included_indices] = 1.0


    return (rho_slice, frame_idx)


class TemporalInterfaceSubcommand(Subcommand):
    ''' Note this will inherit a work manager from parent (which is always the TemporalInterface main instance.
    Common args and methods for any Temporal Interface/Density subcommands; i.e. trajectory input processing, 
    Rho calculation and averaging (assuming the inheriting subclass initializes the voxel grid appropriately'''

    # Expect that derived subcommand classes will fill these in.
    #   Specifies how to fill out subparser
    subcommand = None
    help_text = None
    description = None

    def __init__(self, parent):
        super(TemporalInterfaceSubcommand,self).__init__(parent)

        # Initialized in process_args
        self.univ = None
        self.mol_sel_spec = None

        self.start_frame = None
        self.last_frame = None

        self.outpdb = None

        # Initialized in setup_grid
        #   The specifics of this are handled by appropriate subclass:
        #      TemporalInterfaceInit: Initialize from first frame of input, 
        #          determine (initial) voxels to exclude using distance args
        #
        #      TemporalInterfaceAnal: Load this from input file (generated by '...Init')

        # All bounds are 1-d arrays of *total* boundaries in each dimension
        #   possible positions must fall between [min_bound, max_bound) for each dim
        self.x_bounds = None
        self.y_bounds = None
        self.z_bounds = None

        # shape (n_total_gridpts, ) binary array to mask excluded gridpts.
        #    Indexing is C-style; i.e. :
        #    for xpt in x:
        #        for ypt in y:
        #            for zpt in z:
        #                i += 1
        self.gridpt_mask = None
        self._gridpt_mask_assign = None

        # shape (n_included_gridpts, ) of floats. Average reference water 'densities' for each voxel
        #    Initialized as array of 1's for Init, or from reference vals for Anal
        self.rho_water_ref = None

        self.water_dist_cutoff = None

        # Initialized after 'calc_rho' called

        # (n_frames, n_included_pts) : (non-normalized) number of waters in each voxel, for each frame
        self.rho = None
        # (n_included_pts,) : (non-normalized) number of waters in each voxel, averaged over all frames
        self.rho_avg = None


    # These properties and method will raise exceptions if 'setup_grid' not called

    @property
    def x_len(self):
        return self.x_bounds.size

    @property
    def y_len(self):
        return self.y_bounds.size

    @property
    def z_len(self):
        return self.z_bounds.size
    
    @property
    def n_pts_total(self):
        return (self.x_len * self.y_len * self.z_len)

    @property
    def n_pts_included(self):
        return self.gridpt_mask.sum()
    
    @property
    def n_frames(self):
        return self.last_frame - self.start_frame

    # look-up that gives an index of an included voxel in n_pts_included,
    #    given an index of the included voxel in n_pts_total 
    #  i.e. - given the global index of a voxel (over the list of **all** voxels)
    #     give the index of that voxel in the shortened list of only included voxels
    @property
    def gridpt_mask_assign(self):
        if self._gridpt_mask_assign is None:
            self._gridpt_mask_assign = np.cumsum(self.gridpt_mask, dtype=np.int) - 1
    
        return self._gridpt_mask_assign

    @property
    def rho_avg_norm(self):
        return self.rho_avg / self.rho_water_ref
    
    def add_args(self, parser):
        
        # Common args for trajectory processing
        sgroup = parser.add_argument_group('Trajectory Input Options')
        sgroup.add_argument('-c', '--grofile', metavar='INPUT', type=str, required=True,
                            help='Input structure file')
        sgroup.add_argument('-f', '--trajfile', metavar='XTC', type=str, required=True,
                            help='Input XTC trajectory file')
        sgroup.add_argument('-b', '--start', type=int, default=0,
                            help='First timepoint (in ps)')
        sgroup.add_argument('-e', '--end', type=int, 
                            help='Last timepoint (in ps)')
        sgroup.add_argument('--mol-sel-spec', type=str, default=SEL_SPEC_HEAVIES,
                            help='A custom string specifier for selecting solute atoms, if desired')
        ogroup = parser.add_argument_group('Generalized output options')
        ogroup.add_argument('-opdb', '--outpdb', type=str, default='voxels',
                            help='Output voxels as PDB files with this base name. Two files are outputted: [opdb]_norm.pdb and [opdb]_avg.pdb')
        parser.add_argument('--block-size', type=int,
                            help='split jobs into blocks of this many frames')

    def process_args(self, args):

        try:
            self.univ = u = MDAnalysis.Universe(args.grofile, args.trajfile)
        except:
            print "Error processing input files: {} and {}".format(args.grofile, args.trajfile)
            sys.exit()

        assert np.array_equal(self.univ.dimensions[3:], np.array([90.,90.,90.])), "not a cubic box!"

        if (args.start > (u.trajectory.n_frames * u.trajectory.dt)):
            raise ValueError("Error: provided start time ({} ps) is greater than total time ({} ps)"
                             .format(args.start, (u.trajectory.n_frames * u.trajectory.dt)))

        self.start_frame = int(args.start * u.trajectory.dt)
        if args.end is not None:
            self.last_frame = int(args.end * u.trajectory.dt)
        else:
            self.last_frame = u.trajectory.n_frames

        if args.mol_sel_spec is not None:
            self.mol_sel_spec = args.mol_sel_spec
            try:
                self.univ.select_atoms(self.mol_sel_spec)
            except SelectionError:
                raise ArgumentTypeError('invalid molecule selection spec: {}'.format(args.mol_sel_spec))


        self.outpdb = args.outpdb

        log.info('n workers: {}'.format(self.n_workers))
        log.info('n frames: {}'.format(self.n_frames))

    def calc_rho(self):

        self.rho = np.zeros((self.n_frames, self.n_pts_included), dtype=rho_dtype)


        def task_gen():

            for frame_idx in xrange(self.start_frame, self.last_frame):

                self.univ.trajectory[frame_idx]
                #water_ow = self.univ.select_atoms("name OW and around {} ({})".format(self.water_dist_cutoff+3, self.mol_sel_spec)).positions
                water_ow = self.univ.select_atoms('name OW').positions
                args = ()
                kwargs = dict(frame_idx=frame_idx,  water_ow=water_ow, n_pts_included=self.n_pts_included, 
                              gridpt_mask=self.gridpt_mask, gridpt_mask_assign=self.gridpt_mask_assign,
                              x_bounds=self.x_bounds, y_bounds=self.y_bounds, z_bounds=self.z_bounds)
                #log.info("Sending job (frame {})".format(frame_idx))
                if frame_idx % 100 == 0:
                    log.info("Sending frame {} of {}".format(frame_idx, self.last_frame))
                yield (_calc_rho, args, kwargs)

        # Splice together results into final array of densities
        #for future in self.work_manager.submit_as_completed(task_gen(), queue_size=self.max_queue_len):
        for future in self.work_manager.submit_as_completed(task_gen(), queue_size=self.max_queue_len):
            #import pdb; pdb.set_trace()
            rho_slice, frame_idx = future.get_result(discard=True)
            self.rho[frame_idx-self.start_frame, :] = rho_slice
            del rho_slice

        self._get_rho_avg()

    def _get_rho_avg(self):

        self.rho_avg = self.rho.mean(axis=0)
        log.info("total : {}".format(self.rho_avg.sum()))

        if self.rho_avg.sum() == 0:
            log.error('All voxels are empty')
            raise 
        #non_excluded_indices = self.rho_avg < 0.1
        #non_excluded_rho_avg = self.rho_avg[non_excluded_indices]

        min_rho = self.rho_avg.min()
        max_rho = self.rho_avg.max()
        mean_rho = self.rho_avg.mean()
        log.info("Average Rho: Min rho: {}, Max rho: {}, avg rho: {}, avg rho*npts: {}".format(min_rho, max_rho, mean_rho, mean_rho*self.n_pts_included))

        min_rho = self.rho_avg_norm.min()
        max_rho = self.rho_avg_norm.max()
        mean_rho = self.rho_avg_norm.mean()
        err_rho = self.rho_avg_norm.std()
        log.info("Normalized Average Rho: Min rho: {}, Max rho: {}, avg rho: {}, std rho: {}".format(min_rho, max_rho, mean_rho, err_rho))
        anomalous_idx = np.where(self.rho_avg_norm - mean_rho >= 3*err_rho)
        log.info("anomalous indices (rho - mean >= 3*std(normalized_rho)): {}".format(anomalous_idx))


    #TODO: move this elsewhere
    def do_pdb_output(self):

        np.savetxt('rho_avg.dat', self.rho_avg)
        np.savetxt('rho_avg_norm.dat', self.rho_avg_norm)

        if self.n_pts_included == 0:
            log.warning('No voxels included! Skipping PDB output.')
            return
        # Do we want to store this in memory instead?
        gridpts = cartesian([self.x_bounds, self.y_bounds, self.z_bounds]) + 0.5
        gridpts = gridpts[self.gridpt_mask]

        log.info("outputing data for {} voxels".format(self.n_pts_included))

        # How often voxel is filled w.r.t. voxel under unbiased ensemble
        tempfactors = np.clip(self.rho_avg_norm, 0, 100)
        #tempfactors = np.clip(tempfactors, 0, 100)
        
        top = mdtraj.Topology()
        c = top.add_chain()

        cnt = 0
        for i in range(self.n_pts_included):
            cnt += 1
            r = top.add_residue('II', c)
            a = top.add_atom('II', mdtraj.element.get_by_symbol('VS'), r, i)

        with mdtraj.formats.PDBTrajectoryFile('{}_norm.pdb'.format(self.outpdb), 'w') as f:
            f.write(gridpts, top, tempfactors=tempfactors)

        # Do it again with the absolute rho values (rho_avg instead of rho_avg_norm)
        tempfactors = self.rho_avg * 100
        with mdtraj.formats.PDBTrajectoryFile('{}_avg.pdb'.format(self.outpdb), 'w') as f:
            f.write(gridpts, top, tempfactors=tempfactors)

    def setup_grid(self):
        ''' Derived classes must figure out how to appropriately initialize voxel grid'''
        raise NotImplementedError

    def do_output(self):
        '''Derived class should figure out what to output'''
        raise NotImplementedError

    def go(self):

        self.setup_grid()
        self.calc_rho()
        self.do_output()


class TemporalInterfaceInitSubcommand(TemporalInterfaceSubcommand):
    subcommand='init'
    help_text='Initialize voxel grid, determine voxels to include/exclude, and normalized rhos for each voxel'
    description = '''\
Initialize voxel grid from input args, calculate rho for each voxel from input data, and output voxel limits in each dimension, 
a list of excluded voxels, and the rho for each included voxel. All output to be used in subsequent analysis using the 'anal'
command
            input args:
                a) a structure and trajectory file for (presumably) an unbiased simulation
                b) a solute definition (by --molspec)
                c) a maximum distance (from solute); any voxels more than this distance are excluded
                d) a minimum distance (from solute); any voxels less than this distance are excluded

              Note: after excluding all voxels acccording to supplied min and max distances, any voxels that have a rho_i==0 will
                 also be excluded from the final voxel list
            outputs:
                a) list of x, y and z limits of voxels (determined by initial box size)
                b) boolean array of excluded, included indices (this, along with limits, above, can be used to reconstruct all included voxels)
                c) list of rho_i's (from above) for each included voxel

    '''

    def __init__(self, parent):
        super(TemporalInterfaceInitSubcommand,self).__init__(parent)

        self.grid_resolution = None
        self.init_out = None

    def add_args(self, parser):
        group = parser.add_argument_group('Grid initialization options')
        group.add_argument('--max-water-dist', type=float, default=6.0,
                            help='maximum distance (in A), from the solute, for which to select voxels to calculate density for each frame. Default 13 A. Sets normalized density to 1.0 for any voxels outside this distance')
        group.add_argument('--min-water-dist', type=float, default=0.0,
                            help='minimum distance (in A), from solute, for which to select voxels to calculate density for. Default 0 A. Sets normalized density to 1.0 for any voxels closer than this distance to the solute')
        group.add_argument('--grid-resolution', type=float, default=1.0,
                            help='Grid resolution (in A). Will construct initial grid in order to completely fill first frame box with an integral number of voxels')
        ogroup = parser.add_argument_group('Initialization-specific output')
        ogroup.add_argument('--init-data-out', type=str, default='init_data.pkl',
                            help='Location to output initialized results for use by \'anal\'')

    def process_args(self, args):
        self.grid_resolution = args.grid_resolution
        self.min_water_dist = args.min_water_dist
        self.max_water_dist = args.max_water_dist
        self.init_out = args.init_data_out

    def setup_grid(self):
        
        n_atoms = self.univ.coord.n_atoms
        box = np.ceil(self.univ.dimensions[:3])

        # Set up marching cube stuff - grids in Angstroms
        #  ngrids are grid dimensions of discretized space at resolution ngrids[i] in each dimension
        n_grids = (box / self.grid_resolution).astype(int)+1

        log.info("Initializing grid from initial frame")
        log.info("Box: {}".format(box))
        log.info("Ngrids: {}".format(n_grids))

        # Construct 'gridpts' array, over which we will perform
        #    nearest neighbor searching for each heavy prot and water atom
        #  NOTE: gridpts is an augmented array - that is, it includes
        #  (margin+2) array points in each dimension - this is to reflect pbc
        #  conditions - i.e. atoms near the edge of the box can 'see' grid points
        #    within a distance (opp edge +- cutoff)
        #  I use an index mapping array to (a many-to-one mapping of gridpoint to actual box point)
        #     to retrieve appropriate real point indices
        self.x_bounds = np.linspace(0,box[0],n_grids[0])
        self.y_bounds = np.linspace(0,box[1],n_grids[1])
        self.z_bounds = np.linspace(0,box[2],n_grids[2])

        # gridpts array shape: (n_pts, 3)
        #   gridpts npseudo unique points - i.e. all points
        #      on an enlarged grid
        gridpts = cartesian([self.x_bounds, self.y_bounds, self.z_bounds])
        gridpts += 0.5
        tree = cKDTree(gridpts)

        # Exclude all gridpoints less than min_dist to protein and more than max dist from prot
        prot_heavies = self.univ.select_atoms(self.mol_sel_spec)
        prot_pos_initial = prot_heavies.positions
        prot_tree = cKDTree(prot_pos_initial)

        # find all gridpoints within max_water_dist A of solute atoms
        #   so we can set the (normalized) rho to 1.0 (to take care of edge effects due to, e.g. v-l interfaces)
        neighbor_list_by_point = prot_tree.query_ball_tree(tree, r=self.max_water_dist)
        neighbor_list = itertools.chain(*neighbor_list_by_point)
        neighbor_idx = np.unique( np.fromiter(neighbor_list, dtype=int) )

        far_pt_idx = np.setdiff1d(np.arange(self.n_pts_total), neighbor_idx)

        # Now find all gridpoints **closer** than min_water_dist A to solute
        #   so we can set the rho to 1.0 (so we don't produce an interface over the solute's excluded volume)
        neighbor_list_by_point = prot_tree.query_ball_tree(tree, r=self.min_water_dist)
        neighbor_list = itertools.chain(*neighbor_list_by_point)

        close_pt_idx = np.unique( np.fromiter(neighbor_list, dtype=int) ) 

        excluded_indices = np.append(far_pt_idx, close_pt_idx)
        assert excluded_indices.shape[0] == far_pt_idx.shape[0] + close_pt_idx.shape[0]

        # Finally, set up the initial gridpt_mask array
        self.gridpt_mask = np.ones(self.n_pts_total, dtype=bool)
        self.gridpt_mask[excluded_indices] = False

        self.rho_water_ref = np.ones(self.n_pts_included, dtype=rho_dtype)
        self.max_water_dist_cutoff = self.max_water_dist

        log.info("Point grid set up")   

    def do_output(self):
        ''' Need to remove any voxels that are always empty'''

        log.info('Excluding voxels that are always empty...')
        log.info('n_voxels prior to excluding empties: {}'.format(self.n_pts_included))

        zero_indices = np.where(self.rho_avg==0)[0]
        good_indices = np.arange(self.n_pts_included, dtype=np.int)
        good_indices = np.setdiff1d(good_indices, zero_indices)
        # index of included pt => its index in the global scheme
        included_to_tot_indices = np.arange(self.n_pts_total, dtype=np.int)[self.gridpt_mask]
        # Exclude the (global) indices of any voxels that have rho of zero
        #   rho_avg is indexed by the indices in the range of [0, n_pts_included), while
        #   gridpts_mask is indexed globally, hence the lookup array
        global_indices_to_exclude = included_to_tot_indices[zero_indices]
        log.info('  Excluding an additional {} voxels'.format(global_indices_to_exclude.shape[0]))
        #update the gridpt_mask
        self.gridpt_mask[global_indices_to_exclude] = False
        self.rho_avg =  self.rho_avg[good_indices]
        self.rho_water_ref = self.rho_water_ref[good_indices]
        
        assert np.array_equal(np.ones(self.n_pts_included), self.rho_water_ref)


        ## output some pickling stuff ##
        output_payload = (self.x_bounds, self.y_bounds, self.z_bounds, self.gridpt_mask, self.rho_avg, self.water_dist_cutoff)
        with open(self.init_out, 'w') as pickle_outfile:
            pickle.dump(output_payload, pickle_outfile)

        self.do_pdb_output()


class TemporalInterfaceAnalSubcommand(TemporalInterfaceSubcommand):
    subcommand='anal'
    help_text=''
    description = '''\
'Anal' is for analysis, not anal sex. Run time-averaged interace analysis on trajectory. Load pre-initialized voxel grid definitions and reference rho values for each voxel,
And then calculates average rho and normalized rho values for input data trajectory
    '''

    def __init__(self, parent):
        super(TemporalInterfaceAnalSubcommand,self).__init__(parent)

        # pickled file output by 'Init'
        self.init_data = None

    def add_args(self, parser):
        igroup = parser.add_argument_group('Anal-specific input options')
        igroup.add_argument('--init-data', type=str, default='init_data.pkl',
                            help='Filename of grid information outputted by \'init\'')

    def process_args(self, args):
        self.init_data = args.init_data

    def setup_grid(self):

        log.info('Loading data from initfile {}...'.format(self.init_data))
        
        try:
            with open(self.init_data, 'r') as init_datafile:
                init_dump = pickle.load(init_datafile)

                self.x_bounds, self.y_bounds, self.z_bounds, self.gridpt_mask, self.rho_water_ref, self.max_water_dist = init_dump

        except:
            log.error('Could not load input file')
            raise IOError 

        log.info('...Grid successfully initialized')

    def do_output(self):
        self.do_pdb_output()

class TemporalInterface(ParallelTool):
    prog = 'temporal interface'
    subcommands=[TemporalInterfaceInitSubcommand, TemporalInterfaceAnalSubcommand]
    subparsers_title= 'Temporal density-averaging modes'
    description = '''\
Conduct time-averaged density analysis on a given dataset (contrast with interface.py, which coarse-grains the density field for each 
iteration in the trajectory)
'''

    def __init__(self):
        super(TemporalInterface,self).__init__()
        self._subcommand = None
        self._avail_subcommand = {subcommand_class.subcommand: subcommand_class(self) for subcommand_class in self.subcommands}

    def add_args(self, parser):
        subparsers = parser.add_subparsers(title=self.subparsers_title)

        for instance in self._avail_subcommand.itervalues():
            instance.add_subparser(subparsers)

    def process_args(self, args):
        self._subcommand = args.subcommand
        self._subcommand.process_all_args(args)

    def go(self):
        self._subcommand.go()


if __name__=='__main__':
    TemporalInterface().main()


